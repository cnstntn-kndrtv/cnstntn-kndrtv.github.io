---
title: NER и максимальный поток.
author: Constantin Kondratyev
date: 2021-09-08 20:27:00 +0300
categories: [ Projects, АрхиГраф.Логос ]
tags: [ RDF, NLU, NER,  велосипед ]
math: true
mermaid: true
---

Решая задачу распознавания именованных сущностей (NER) столкнулся с такой штукой - для morphologically rich (синтетических) языков свойственен почти случайный порядок слов  в предложении.  
При этом задачу NER решают обычно на датасетах с разметкой IOB (Begin, Inner, Out), учитывающую последовательность токенов. Например в тексте "Нижний Новгород, мать его." будут такие теги - `B-LOC, I-LOC, O, O` ( Начало Location, продолжение Location и 2 слова без меток). Но мы, носители великого и могучего, можем запросто сказать так: "Нижний, мать его, Новгород" и модель, обученная на таком датасете, выдаст `B-LOC, O, O, B-LOC`. Чтобы собрать Сущность НижнийНовгород, нужно придумать еще один слой, который соберет эти 2 "начала" в одну "цепочку".  
Как-то так это можно представить графически:  

```mermaid
graph
    Нижний --- НижнийНовгород
    мать
    его
    Новгород --- НижнийНовгород

```  

А ещё у нас могут быть какие-то другие сущности, например НижнийТагил:  

```mermaid
graph
    Нижний --- НижнийНовгород
    Нижний --- НижнийТагил
    мать
    его
    Новгород --- НижнийНовгород

```  

И конечно же может случиться так что токены сущностей разбиты не только незначимыми токенами (O), но и токенами, являющимися упоминанием других сущностей. Как-то так:  

```mermaid
graph
    t1 --- e1
    t1 --- e3
    t2 --- e2
    t2 --- e3
    t3 --- e3
    t4 --- e1
    t4 --- e2
    t5 --- e2
    t6 --- e3
    t7 --- e2

```  

Конечно на практике такой текст представить сложно, но такое запросто может случиться.  
Продолжаем. При чем здесь поток (в заголовке)? Добавим направление в наш граф, 2 ноды `Source` и `Target` и представим, что из `Source` в `Target`, через вершины типа `E` и `T`, течет поток (молочные реки к кисельным берегам сильного ИИ). Ограничим количество потока, вытекающего из `Source` количеством вершин типа `T`. В скобках на графе указано количество вытекающего потока из ноды:  

```mermaid
graph
    Source["Source (4)"] --> e1
    Source --> e2
    e1["e1 (2)"] --> t1
    e2["e1 (1)"] --> t1
    e1 --> t4
    t1["t1 (1)"] --> Target
    t2["t2 (1)"] --> Target
    t3["t3 (1)"] --> Target
    t4["t4 (1)"] --> Target

```  
Выбирая между `e1` и `e2` берем ту вершину, через которую из `Source` в `Target` может протечь максимальное количество потока.  
Конечно не так всё просто, детали я опишу в другой статье. Важно что этот подход позволяет добавить к выбору нод типа `E` еще и информацию о семантических отношениях сущностей, но это совсем другая история.  
















